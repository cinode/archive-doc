
Blob validation
+++++++++++++++

Each blob must reveal extra cryptographic properties
that allow nodes to quickly accept or reject particular
blob when received from the network. This requirement
is needed to enforce write access authorization. The
validation process will basically prevent blobs
generated by unauthorized users from spreading
through the network.

The validation process must be done in a cryptographic
way so that there are no known practical attacks that
could make the validation process useless. The BID identifier
is also used during this process to prevent overwriting
the blob by generating a new one with the same BID.

Next sections describe currently used validation methods.
Future versions of the protocol may extend this set
by adding validation rules needed by particular blob types.

Hash-based validation
----------------------

Hash-based validation is the simplest one and is generally
applied to all blob types holding content rather than
links to other blobs.

The idea is to use the hash of encrypted blob data as a blob id.
The hash used is SHA-512. Using this validation method means that
no one can overwrite the content of a blob due to the irreversible
nature of cryptographic hashes. This applies to blob's creator too
resulting in a write-once like kind of operation.

The process of content change require creating new blob with altered
data and replacing all references to the old blob with the new one.

Although this way of handling data comes with many restrictions,
it will help dealing with delayed content updates making the network
less vulnerable for inconsistencies caused by partial updates
(similarly to copy-on-write methods).

The encryption key for the blob's data is generated as the hash of
the unencrypted blob's content. This means that given data will always
have the same encrypted representation and will allow global anonymous
data deduplication.

The IV (initialization vector) for the data encryption
cipher is zero in al cases. This doesn't reduce the
security since the cipher initialization is based on a hash
value that theoretically depends on every bit of the plain
data. This key different for every blob is sufficient
enough to prevent any attacks targetted on the beginning
of encrypted data.

.. image:: hashvalidation.*


Sign-based validation
---------------------

This validation method is based on a cryptographic sign of blob's content.
Every blob using this method is associated with a public/private key pair.
Blob's id is a hash (SHA-512) of the public key (public key FingerPrint) so that
the blob with such id can not be overwritten by other users.

Following information is stored for a particular blob:

 - Public Key (DER-encoded)
 - Digital Sign (calculated from Version Number and Encrypted Data fields)
 - Version Number
 - Encrypted Data
 
For validation purposes, all fields apart from the encrypted data are
stored in a plain form. The encryption key of a data is based on a hash
value (SHA-512) of the Private Key.   

The blob can be altered over time resulting in coexistence of multiple
contents assigned to the same blob id. Nodes must be able to find the most
recent one to keep the network up to date. For this particular reason,
each blob stores it's Version Number. Selection of the most recent blob
version is a part of blob's validation process.

The user authorized to change the blob must know blob's private key and
it's most recent Version Number. The new Version Number is generated by
adding non-zero positive number to the previous one (it should not be 1
to harden analyzing the number of blob updates). The new Version Number combined with
Encrypted Data is signed with the Private Key. New blob is assembled from
all needed parts and is propagated to all major cloning nodes (if known).

The validation of a blob is made in the following steps:

 - The blob's Public Key is validated against blob id by comparing key's
   hash value with the id
 - The Version Number is compared with the one of locally stored blob.
   If Version Numbers are the same, an additional comparison of Digital Sign
   values is performed in order to deal with same-version attacks.
   
   - if versions/signs are equal, nothing is done
   - if the version/sign of the received blob is higher than the locally
     stored one, the local one is replaced by the received one
   - if the version/sign of the received blob is lower than the locally
     stored one, the local blob is sent back in a reply to blob update
     request so that the peer can update it's local version

 - The digital sign of content and version number is validated
 
 TODO: Consider requiring some "random" bytes at the beginning of the Unencrypted Data or
       to provide different initialization vectors for it. This may be needed if blobs using
       this validation method don't change initial bytes (16 for AES), what would result
       in unaltered initial bytes in the encrypted version too.

The initialization vector of the cipher is made of the version
number by padding it's reprezentation with zeroes or choosing
as mch bytes from the beginning of this representation as required
by the IV size. The representation uses the same rules as the usual
serialization of integers. This alteration of the IV every time a
blob changes will prevent possible attacks towards encrypted data
where choosing same plain text will produ e same cipher text.
TODO: How about same version attacks here?

.. image:: signvalidation.*
