Blob validation
+++++++++++++++

Each blob must reveal extra cryptographic properties
that allow nodes to quickly accept or reject particular
blob when received from the network. This requirement
is needed to enforce write access authorization. The
validation process will basically prevent blobs
generated by unauthorized users from spreading
through the network.

The validation process must be done in a cryptographic
way so that there are no known practical attacks that
could make the validation process useless. The BID identifier
is also used during this process to prevent overwriting
the blob by generating a new one with the same BID.

Next sections describe currently used validation methods.
Future versions of the protocol may extend this set
by adding validation rules needed by particular blob types.

Hash-based validation
----------------------

Hash-based validation is the simplest one and is generally
applied to all blob types holding content rather than
links to other blobs.

The idea is to use the hash of encrypted blob data as a blob id.
The hash used is SHA-512. Using this validation method means that
no one can overwrite the content of a blob due to the irreversible
nature of cryptographic hashes. This applies to blob's creator too
resulting in a write-once like kind of operation.

The process of content change require creating new blob with altered
data and replacing all references to the old blob with the new one.

Although this way of handling data comes with many restrictions,
it will help dealing with delayed content updates making the network
less vulnerable for inconsistencies caused by partial updates
(similarly to copy-on-write methods).

The encryption key for the blob's data is generated as the hash of
the unencrypted blob's content. This means that given data will always
have the same encrypted representation and will allow global anonymous
data deduplication.

The IV (initialization vector) for the data encryption
cipher is zero in all cases. This doesn't reduce the
security since the cipher initialization is based on a hash
value that theoretically depends on every bit of the plain
data. This key different for every blob is sufficient
enough to guarantee semantic security.

.. image:: hashvalidation.*


Sign-based validation
---------------------

This validation method is based on a cryptographic sign of blob's content.
Every blob using this method is associated with a public/private key pair.
Blob's id is a hash (SHA-512) of the public key (public key FingerPrint) so that
the blob with such id can not be overwritten by other users.

Following information is stored for a particular blob:

 - Public Key (DER-encoded)
 - Digital Sign (calculated from Version Number and Encrypted Data fields)
 - Version Number
 - Encrypted Data
 
For validation purposes, all fields apart from the encrypted data are
stored in a plain form. The encryption key of a data is based on a hash
value (SHA-512) of the Private Key.   

The blob can be altered over time resulting in coexistence of multiple
contents assigned to the same blob id. Nodes must be able to find the most
recent one to keep the network up to date. For this particular reason,
each blob stores it's Version Number. Selection of the most recent blob
version is a part of blob's validation process.

The user authorized to change the blob must know blob's private key and
it's most recent Version Number. The new Version Number is generated by
adding non-zero positive number to the previous one (it should not be 1
to harden analyzing the number of blob updates). The new Version Number combined with
Encrypted Data is signed with the Private Key. New blob is assembled from
all needed parts and is propagated to all major cloning nodes (if known).

The validation of a blob is made in the following steps:

 - The blob's Public Key is validated against blob id by comparing key's
   hash value with the id
 - The digital sign of content and version number is validated
 - The Version Number is compared with the one of locally stored blob.
   If Version Numbers are the same, an additional comparison of Digital Sign
   values is performed in order to deal with same-version attacks.
   
   - if versions/signs are equal, nothing is done
   - if the version/sign of the received blob is higher than the locally
     stored one, the local one is replaced by the received one
   - if the version/sign of the received blob is lower than the locally
     stored one, the local blob is sent back in a reply to blob update
     request so that the peer can update it's local version

The initialization vector of the cipher is made of the version
number by padding it's serialized representation with zeroes or using
required number of bytes from the beginning of this representation.
Since the Version Number must change every time a new data
is introduced, it reveals properties of a cryptographic nounce
and thus can be securely used as the IV. This guarantees
semantic security.

In case of an attack where the same Version Number is being
reused, the attacker must already be in a possession of the private key.
This would allow the IV to be reused breaking semantic security. Since the
attacker is already in a possession of the private key and thus also the
data encryption key, there are no benefits for him other
than small disturbance of the validation methods.

.. image:: signvalidation.*
