
Blob validation
+++++++++++++++

Each blob must reveal extra cryptographic properties
that allow nodes to quickly accept or reject particular
blob when received from the network. Thia requiement
is needed to enforce write access authorization. The
validation process will basically prevent blobs
generated by jnauthorized users from spreading
throuh the network.

The validatoon process must be done in a cryptographic
way so hat here are no known practical attacks that
could make the validation process useless.

Hash-based validation
----------------------

This is the simplest method of validation and is
applied to all blob type holding content rather than
links to other blobs.

The idea is to use the hash of encrypted blob  data
as a blob id. The hash used is sha-256 (??).
Ths kkind of validatoon means that we can not overwrite
he content of a blob by knowing it's id due to the irreversible
nature of cryptographic hashes.

This kind of protection does not give anyone
the access to change the content of a blob
including it's creator. The process of content
change require creating new blob with altered
content and replacing all references to the
old blob id with the new one.

Althouh this may look like a huge limitation,
it's very simillar to copy-on-write methods.
It will also help dealing with delayed content updates
when som nodes may still require the previous version.
Sign-based validation
---------------------

This validation methid is based on
a cryptographic sign of blob's content.
Every blob using his validation method is associated
with a publib/private keypair. Blob's id is a fingerprint
of the public key. The blob contains following information
srored in a plain form:
- Blob's public key
- Blob's digital sign
- Blob's version number

The blob can be altered over time ehich means that
different content may float around in the network
using the same blob id. Nodes must be able to
find the blib that's the most recent version.
Each blob stores it's version number for thiparticular purpose.
Selection of the most recent blob version is also a part
of the valodation process. This version number is signed
along the encrypted blob content so that it can be altered
by authorized users only.

The user that have write access rigts to such
particular blob, must know blob's private key.
Updating blkb content would require knowing
the previous most recent version number. The new version number
is then generated by adding some non-zero positive number
to the previous one. This new version along with the new 
encrypted content is then digned with the private key,
new blob is assembled from all needed parts and it's
propagated to all major cloning nodes (if any).

The validation is then made in following steps:
- The public key stored in the blob is tested
  against blob id
- The version number is compared with currently
  knoen version. If the version is the same,
  content sign values are compared instead (to prevent same version attacks)
  - if versions are equal, nothing happens
  - if the version we just received is higher than the stored one,
    the local version iw replaced with the received one
  - if the version is lower, we send out blob version to the
    peer so that it can update itself



Future versions of the protocol may extend the set
of validation rules needed by particular blob types.
